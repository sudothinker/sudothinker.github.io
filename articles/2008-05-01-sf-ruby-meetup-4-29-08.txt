--- 
author: Sudothinker
title: SF Ruby Meetup 4.29.08
date: 01/05/2008
slug: sf-ruby-meetup-4-29-08

Went to my first <a href="http://ruby.meetup.com/6/calendar/7753596/">SF meetup</a> today, hosted by the good folks at <a href="http://www.affinitylabs.com/">Affinity Labs</a>.

<h3>Higher-Order Procedures</h3>
The first talk was by Bala Paranj on the topic of Higher-Order Procedures in Ruby. He presented code like the following:

<pre>
<code class="ruby">def make_filter(predicate)
  lambda do |list|
    results = []
    list.each do |r|
      results << r if predicate.call(r)
    end
    results
  end
end

even_filter = make_filter(lambda{|x| x % 2 == 0})

p even_filter.call([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
# [2, 4, 6, 8, 10]</code>
</pre>

Im kind of conflicted with the above snippet - There are advantages of make_filter returning a proc:

<ol>
<li>You can delay code execution until later in the program</li>
<li>It allows for more reusable code as you can pass filters around rather than repeating even procs</li>
</ol>

For (1) - this can be said as a big advantage of higher-order procedures in general, you don't have to deal with data until the last possible point. With this approach you can separate business logic and data crunching through the application. For (2), I'm not so convinced, while it does make for reusable code, there is an extra level of indirection created and I feel that the even_filter would have to be used in multiple places in the app for it to be justified.

The alternative which I would probably implement to achieve the above:

<pre>
<code class="ruby">def even?
  lambda {|x| x % 2 == 0}
end

def filter_list(list, predicate)
  list.inject([]) do |result, element|
    result << element if predicate.call(element)
    result
  end
end

p filter_list([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], even?)
# [2, 4, 6, 8, 10]</code>
</pre>

I would argue that this is a better abstraction to have, you are still passing around predicates but I feel that the filter_list is more re-useable than the make_filter method. With this implementation we can reuse logic like determining if a number is even, and we also get the flexibility of applying any predicate to a list to filter elements. Another reason why I like this is because I don't like calling .call on what seem to be method objects, in the above example we had to use even_filter.call, which I see as cumbersome, with the later approach we can use filter_list as a method and call with straight parameters.

The above code can be found [on my github page](http://github.com/sudothinker/ruby/blob/0ae925c28f035c9eff15b54384e1d730a92dd4a1/filters.rb).

<h3>Erector</h3>

<a href="http://evang.eli.st/blog">Pat Maddox</a> presented a view template engine <a href="http://erector.rubyforge.org">Erector</a>

Erector is an alternative to other templating engines like <a href="http://redhanded.hobix.com/inspect/markabyForRails.html">Markaby</a> and <a href="http://haml.hamptoncatlin.com/">HAML</a>. It is becoming a crowded field with over 19 templating engines now competing for dominance in rails. Since its inception, rails has been using erb for view templates. While this does have its limitations, it has stood the test of time. (Newer frameworks like merb allow for a more flexibility in choosing a template engine and support for markaby and HAML exist via gems for merb applications.)

So why is Erector different? Well the logic for starting Erector which I understood from the presentation was that writing erb sucks, and that Markaby and HAML are either not good enough or just look ugly. While I agree that HAML looks ugly, I am not really convinced that Markaby should be shot down quite so quickly before investing time on a new template engine.

Erector feels a lot like Markaby in many respects, the main difference I see is the code organization, Markaby follows erb convention in laying out your views in that each view reads from top to bottom, but instead of erb and HTML, it uses Ruby. Erector on the other hand splits up common chuncks of markup and functionality into 'widgets' which can get called from controllers via render_widget. It splits up these widgets in order to get reusability and extensibility in the views - these widgets are basically ruby objects and so can be subclassed and extended to gain functionality.

While I think Erector is an interesting concept, I feel the indirection created is very cumbersome. In order to change some copy, you have to find the layout, then follow the indirection of all the widgets which are rendered and then find the text you want to change. Widgets seem a bit like partials to me, but I feel that partials are logically organized and make sense as chunks of markup, making these widget ruby objects of markup just seems like overkill to me and introduces a lot of complexity in view rendering.

<h3>IBM Sharable Code & Mashups</h3>

The last presentation came from <a href="http://www.maximilien.com/homepage/welcome.html">Michael Maximilien</a> on the topic of <a href="http://services.alphaworks.ibm.com/isc/">mashups</a>.

He presented on an interesting system which is basically a DSL for generating mashups. The example given was generating a website which mashes up some flickr photos and digg articles or youtube videos. The process is to write a single 'Recipe' in the DSL which in turn generates a full rails application, complete with migrations and API service calls to generate the mashup. So whats the DSL recipe? Well its everything that defines the mashup. All API calls need to be iterated out, all possible data objects returned by the API, all the views along with the markup for the application...

Another interesting aspect is deployments, you can specify a recipe for a particular deployment destination, for example facebook or iphone - define all the api keys and then generate a new rails application for that target. The main pitfall of something like this is that, although the API data can be reused, you'd have to iterate out all the views for the different deploy targets (Facebook in FBML for example).

This seems interesting, and goes along with the goal of Sharable Code. While I can't see programmers using a tool like this to generate mash ups as they would want more flexibility in the generated code, there may be some appeal for non-programmers who want to get quick functional mashups with minimal initial overhead.

I also found a <a href="http://techwebtv.feedroom.com/?fr_story=a0d9fae7c8e464a2ca314f5d1214604c84f13106&rf=sitemap">video</a> of Michael himself explaining Swashup.

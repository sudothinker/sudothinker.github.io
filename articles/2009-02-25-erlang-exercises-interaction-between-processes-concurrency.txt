--- 
author: Sudothinker
title: "Erlang Exercises: Interaction between processes, Concurrency"
date: 25/02/2009

From <a href="http://erlang.org/course/exercises.html#conc" target="_blank">http://erlang.org/course/exercises.html#conc.</a>

1. Write a function which starts 2 processes, and sends a message M times forewards and backwards between them. After the messages have been sent the processes should terminate gracefully.

<pre><code class="erlang">-module(bouncer).
-export([bounce/1, ping/2, ponger/0]).

% Spawn a pinger and a ponger and message back and forth +M+ times
bounce(M) ->
  Ponger = spawn(bouncer, ponger, []),
  spawn(bouncer, ping, [Ponger, M]).
  
% I'm going to ping +Ponger+ +M+ times  
% When I've done that I'm going to tell Ponger to stop, and I'll stop
ping(Ponger, M) when M > 0 ->
  Ponger ! {self(), ping},
  receive
    {Ponger, pong} ->
      io:format("Ponged"),
      ping(Ponger, M - 1);
    stop ->
      true;
    % This is a safe guard, we only want to count pong's from +Ponger+
    Other ->
      ping(Ponger, M)
  end;
ping(Ponger, 0) ->
  Ponger ! stop.
  
% If I get a ping, im going to pong back  
ponger() ->
  receive
    {From, ping} ->
      io:format("Pinged"),
      From ! {self(), pong},
      ponger();
    stop ->
      true;
    % We'll ping anyone back, but it has to be in form {From, ping}
    Other ->
      ponger()
  end.
</code></pre>

